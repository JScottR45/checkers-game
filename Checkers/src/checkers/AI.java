package checkers;

import javafx.animation.PauseTransition;
import javafx.scene.layout.BorderPane;
import javafx.scene.text.Text;
import javafx.util.Duration;

import java.util.LinkedList;
import java.util.Random;

import static checkers.OpponentType.*;
import static checkers.PieceType.*;
import static checkers.PieceColor.*;

class AI {
    /** The type of opponent of this AI (either EASY, MEDIUM or HARD). */
    private OpponentType opponentType;
    /** The Checkers board abstraction. */
    private Board board;
    /** The Checker's board GUI object. */
    private BoardGUI boardGUI;
    /** A Linked List containing the best available moves that this AI can choose, all of which have the same
     *  move value. */
    private LinkedList<Move> bestMoves;
    /** A Linked List containing all of the moves generated by the minimax algorithm. Used for undo purposes. */
    private LinkedList<Move> savedMoves;
    /** The initial value of every AI move node in the minimax algorithm. */
    private static final int MAXIMIZER_INITIAL_VALUE = Integer.MIN_VALUE;
    /** The initial value of every AI opponent move node in the minimax algorithm. */
    private static final int MINIMIZER_INITIAL_VALUE = Integer.MAX_VALUE;

    /** Initializes the starting state of this AI based on OPPONENTTYPE and BRD. */
    AI(OpponentType type, Board brd, BoardGUI gui) {
        opponentType = type;
        board = brd;
        boardGUI = gui;
        bestMoves = new LinkedList<>();
        bestMoves.add(new Move(null, null, MAXIMIZER_INITIAL_VALUE, false));
        savedMoves = new LinkedList<>();
    }

    /** Makes a move corresponding to the level of difficulty by which this AI is supposed to play. */
    void makeMove() {
        if (opponentType == COMPUTER_EASY) {
            generateMove(1);
        } else if (opponentType == COMPUTER_MEDIUM) {
            generateMove(3);
        } else {
            generateMove(7);
        }
    }

    /** Selects a move from the bestMoves Linked List after using the minimax algorithm to find and place one or more
     *  best moves into the list based on the value of MOVESAHEAD. Upon selecting a move, the move is made. */
    private void generateMove(int movesAhead) {
        Move selectedMove;
        Piece piece;
        BorderPane previousTile;
        BorderPane destTile;
        LinkedList<BorderPane> previousTiles;
        LinkedList<Piece> capturedPieces;
        LinkedList<int[]> attacksMade;
        Random rand = new Random();

        miniMax(movesAhead, MAXIMIZER_INITIAL_VALUE, MINIMIZER_INITIAL_VALUE);
        selectedMove = bestMoves.get(rand.nextInt(bestMoves.size()));

        if (selectedMove.isAttack()) {
            piece = selectedMove.getPiece();
            previousTiles = new LinkedList<>();
            capturedPieces = new LinkedList<>();
            attacksMade = selectedMove.getMove();

            previousTiles.add(Controller.findTile(piece.getCurrRow(), piece.getCurrCol()));

            for (int[] attack : attacksMade) {
                capturedPieces.add(board.getPieceGUILoc(attack[2] - 1, attack[3] - 1));
                previousTiles.add(Controller.findTile(attack[0] - 1, attack[1] - 1));
                board.movePiece(piece.getCurrRow(), piece.getCurrCol(), attack[0] - 1, attack[1] - 1);
                board.removePieceAbstractionLoc(attack[2], attack[3]);
                piece.setLocation(attack[0] - 1, attack[1] - 1);
            }
            updateGUIPostAttack((BlackPiece) piece, attacksMade, capturedPieces, previousTiles);

        } else {
            piece = selectedMove.getPiece();
            int[] move = selectedMove.getMove().getFirst();
            previousTile = Controller.findTile(piece.getCurrRow(), piece.getCurrCol());
            destTile = Controller.findTile(move[0], move[1]);
            board.movePiece(piece.getCurrRow(), piece.getCurrCol(), move[0], move[1]);
            piece.setLocation(move[0], move[1]);
            updateGUIPostMove((BlackPiece) piece, previousTile, destTile);
        }
        bestMoves.clear();
        bestMoves.add(new Move(null, null, MAXIMIZER_INITIAL_VALUE, false));
    }

    /** The minimax algorithm. Creates and searches a game tree to a depth corresponding to MOVESAHEAD in order to find the best
     *  move(s). Uses ALPHA/BETA pruning to make the search faster. The best move and other equally good moves are placed into
     *  the bestMoves Linked List. */
    private int miniMax(int movesAhead, int alpha, int beta) {
        int nodeVal;
        int currVal;

        LinkedList<BlackPiece> blackAttackerPieces;
        LinkedList<RedPiece> redAttackerPieces;
        LinkedList<int[]> possibleAttacks;
        Move savedAttack;

        LinkedList<BlackPiece> blackPieces;
        LinkedList<RedPiece> redPieces;
        LinkedList<int[]> possibleMoves;


        if (movesAhead == 0) {
            return getMoveValue();
        }

        else if (movesAhead % 2 == 1) {
            blackPieces = board.getBlackPieces();
            nodeVal = MAXIMIZER_INITIAL_VALUE;
            blackAttackerPieces = findBlackAttackerPieces();

            if (blackAttackerPieces.size() > 0) {

                for (BlackPiece piece : blackAttackerPieces) {
                    possibleAttacks = Controller.searchForAttacks(piece);

                    for (int[] attack : possibleAttacks) {
                        savedAttack = new Move(piece, true, BLACK);
                        currVal = makeAttack(piece, attack, movesAhead, savedAttack, nodeVal, beta);

                        if (currVal > nodeVal) {
                            nodeVal = currVal;
                        }
                        if (nodeVal > beta) {
                            undoMove();
                            return nodeVal;
                        } else if ((opponentType == COMPUTER_EASY && movesAhead == 1) ||
                                (opponentType == COMPUTER_MEDIUM && movesAhead == 3) ||
                                (opponentType == COMPUTER_HARD && movesAhead == 7)) {
                            if (nodeVal > bestMoves.getFirst().getVal()) {
                                savedAttack.setMoveValue(nodeVal);
                                bestMoves.clear();
                                bestMoves.add(savedAttack);
                            } else if (currVal == bestMoves.getFirst().getVal()) {
                                if (bestMoves.getFirst().getPiece() == null) {
                                    bestMoves.pollFirst();
                                }
                                savedAttack.setMoveValue(nodeVal);
                                bestMoves.add(savedAttack);
                            }
                        }
                        undoMove();
                    }
                }
            } else {
                for (BlackPiece piece : blackPieces) {

                    if (!piece.isOnBoard()) {
                        continue;
                    }

                    possibleMoves = searchForMoves(piece);

                    if (possibleMoves.size() > 0) {
                        for (int[] move : possibleMoves) {
                            makeMove(piece, move);
                            currVal = miniMax(movesAhead - 1, nodeVal, beta);

                            if (currVal > nodeVal) {
                                nodeVal = currVal;
                            }
                            if (nodeVal > beta) {
                                undoMove();
                                return nodeVal;
                            } else if ((opponentType == COMPUTER_EASY && movesAhead == 1) ||
                                    (opponentType == COMPUTER_MEDIUM && movesAhead == 3) ||
                                    (opponentType == COMPUTER_HARD && movesAhead == 7)) {
                                if (nodeVal > bestMoves.getFirst().getVal()) {
                                    savedMoves.getLast().setMoveValue(nodeVal);
                                    bestMoves.clear();
                                    bestMoves.add(savedMoves.getLast());
                                } else if (currVal == bestMoves.getFirst().getVal()) {
                                    if (bestMoves.getFirst().getPiece() == null) {
                                        bestMoves.pollFirst();
                                    }
                                    savedMoves.getLast().setMoveValue(nodeVal);
                                    bestMoves.add(savedMoves.getLast());
                                }
                            }
                            undoMove();
                        }
                    }
                }
            }
        } else {
            redPieces = board.getRedPieces();
            nodeVal = MINIMIZER_INITIAL_VALUE;
            redAttackerPieces = findRedAttackerPieces();

            if (redAttackerPieces.size() > 0) {
                for (RedPiece piece : redAttackerPieces) {
                    possibleAttacks = Controller.searchForAttacks(piece);

                    for (int[] attack : possibleAttacks) {
                        savedAttack = new Move(piece, true, RED);
                        currVal = makeAttack(piece, attack, movesAhead, savedAttack, alpha, nodeVal);

                        if (currVal < nodeVal) {
                            nodeVal = currVal;
                        }
                        if (nodeVal < alpha) {
                            undoMove();
                            return nodeVal;
                        }
                        undoMove();
                    }
                }
            } else {
                for (RedPiece piece : redPieces) {

                    if (!piece.isOnBoard()) {
                        continue;
                    }

                    possibleMoves = searchForMoves(piece);

                    if (possibleMoves.size() > 0) {
                        for (int[] move : possibleMoves) {
                            makeMove(piece, move);
                            currVal = miniMax(movesAhead - 1, alpha, nodeVal);

                            if (currVal < nodeVal) {
                                nodeVal = currVal;
                            }
                            if (nodeVal < alpha) {
                                undoMove();
                                return nodeVal;
                            }
                            undoMove();
                        }
                    }
                }
            }
        }
        return nodeVal;
    }

    /** Returns a numerical value representing the state of the Checkers board. It is used to give moves a "move value".
     *  The greater the number, the better off is the AI. The smaller the number, the better off is the AI's opponent. */
    private int getMoveValue() {
        int blackPlayerScore = board.getBlackPieces().size() - board.getNumCapturedBlackPieces();
        int redPlayerScore = board.getRedPieces().size() - board.getNumCapturedRedPieces();

        if (blackPlayerScore == 0) {
            return Integer.MIN_VALUE;
        } else if (redPlayerScore == 0) {
            return Integer.MAX_VALUE;
        }
        return blackPlayerScore - redPlayerScore;
    }

    /** Reverses the most recently made move. */
    private void undoMove() {
        Move move = savedMoves.pollLast();
        Piece piece = move.getPiece();
        int startRow = move.getStartRow();
        int startCol = move.getStartCol();
        int[] attack;
        Piece capturedPiece;

        if (move.isAttack()) {
            attack = move.getMove().getFirst();
            capturedPiece = move.getCapturedPieces().getFirst();

            board.movePiece(piece.getCurrRow(), piece.getCurrCol(), startRow, startCol);
            piece.setLocation(startRow, startCol);
            board.addPieceGUILoc(capturedPiece, attack[2] - 1, attack[3] - 1);

            if (piece.getColor() == BLACK && (attack[0] - 1) == 7 && !piece.isPermanentKing()) {
                piece.setType(REGULAR);
            } else if (piece.getColor() == RED && (attack[0] - 1) == 0 && !piece.isPermanentKing()) {
                piece.setType(REGULAR);
            }
        } else {
            if (piece.getColor() == BLACK && piece.getCurrRow() == 7 && !piece.isPermanentKing()) {
                piece.setType(REGULAR);
            } else if (piece.getColor() == RED && piece.getCurrRow() == 0 && !piece.isPermanentKing()) {
                piece.setType(REGULAR);
            }
            board.movePiece(piece.getCurrRow(), piece.getCurrCol(), startRow, startCol);
            piece.setLocation(startRow, startCol);
        }
    }

    /** Reverses the last leg of an attack if the attack is a chained attack. */
    private void undoSingleAttack() {
        Move move = savedMoves.getLast();
        int[] attack = move.getMove().pollLast();
        Piece piece = move.getPiece();
        Piece capturedPiece = move.getCapturedPieces().pollLast();

        if (piece.getColor() == BLACK && (attack[0] - 1) == 7 && !piece.isPermanentKing()) {
            piece.setType(REGULAR);
        } else if (piece.getColor() == RED && (attack[0] - 1) == 0 && !piece.isPermanentKing()) {
            piece.setType(REGULAR);
        }

        board.movePiece(piece.getCurrRow(), piece.getCurrCol(), attack[4] - 1, attack[5] - 1);
        piece.setLocation(attack[4] - 1, attack[5] - 1);
        board.addPieceGUILoc(capturedPiece, attack[2] - 1, attack[3] - 1);
    }

    /** Locates all of the black pieces that can make an attack and returns a Linked List which contains them. */
    private LinkedList<BlackPiece> findBlackAttackerPieces() {
        LinkedList<BlackPiece> blackPieces = board.getBlackPieces();
        LinkedList<BlackPiece> attackerPieces = new LinkedList<>();
        LinkedList<int[]> possibleAttacks;

        for (BlackPiece piece : blackPieces) {
            if (piece.isOnBoard()) {
                possibleAttacks = Controller.searchForAttacks(piece);

                if (possibleAttacks.size() > 0) {
                    attackerPieces.add(piece);
                }
            }
        }
        return attackerPieces;
    }
    /** Locates all of the red pieces that can make an attack and returns a Linked List which contains them. */
    private LinkedList<RedPiece> findRedAttackerPieces() {
        LinkedList<RedPiece> redPieces = board.getRedPieces();
        LinkedList<RedPiece> attackerPieces = new LinkedList<>();
        LinkedList<int[]> possibleAttacks;

        for (RedPiece piece : redPieces) {
            if (piece.isOnBoard()) {
                possibleAttacks = Controller.searchForAttacks(piece);

                if (possibleAttacks.size() > 0) {
                    attackerPieces.add(piece);
                }
            }
        }
        return attackerPieces;
    }

    /** Moves an AI PIECE on the Checkers board. The move is represented by MOVE. Declares the PIECE a King if it has
     * reached the opposite side of the board. */
    private void makeMove(Piece piece, int[] move) {
        Move savedMove = new Move(piece, move);
        savedMoves.add(savedMove);
        board.movePiece(piece.getCurrRow(), piece.getCurrCol(), move[0], move[1]);
        piece.setLocation(move[0], move[1]);

        if (piece.getColor() == BLACK && move[0] == 7 && piece.getType() == REGULAR) {
            piece.setType(KING);
        } else if (piece.getColor() == RED && move[0] == 0 && piece.getType() == REGULAR) {
            piece.setType(KING);
        }
    }

    /** An AI PIECE makes an attack on its opponent. The attack is represented by ATTACK. If multiple chain attacks are
     *  available after the initial attack, all of the additional chain attacks are made in order to calculate which yields
     *  the best result. This result is stored in SAVEDATTACK. Minimax is called after each attack using MOVESAHEAD, ALPHA,
     *  and BETA. */
    private int makeAttack(Piece piece, int[] attack, int movesAhead, Move savedAttack, int alpha, int beta) {
        int currVal;
        int attackVal;
        LinkedList<int[]> additionalAttacks;
        Piece capturedPiece = board.getPieceGUILoc(attack[2] - 1, attack[3] - 1);

        if (piece.getColor() == RED) {
            attackVal = MINIMIZER_INITIAL_VALUE;
        } else {
            attackVal = MAXIMIZER_INITIAL_VALUE;
        }

        board.movePiece(piece.getCurrRow(), piece.getCurrCol(), attack[0] - 1, attack[1] - 1);
        piece.setLocation(attack[0] - 1, attack[1] - 1);
        board.tempRemovePieceAbstractionLoc(attack[2], attack[3]);
        savedAttack.addAttack(attack, capturedPiece);
        additionalAttacks = Controller.searchForAttacks(piece);

        if (savedAttack.getMove().size() == 1) {
            savedMoves.add(savedAttack);
        }
        if (piece.getColor() == BLACK && (attack[0] - 1) == 7 && piece.getType() == REGULAR) {
            piece.setType(KING);
        } else if (piece.getColor() == RED && (attack[0] - 1) == 0 && piece.getType() == REGULAR) {
            piece.setType(KING);
        } else if (additionalAttacks.size() > 0) {

            for (int[] additionalAttack : additionalAttacks) {
                currVal = makeAttack(piece, additionalAttack, movesAhead, savedAttack, alpha, beta);

                if (piece.getColor() == RED && currVal <= attackVal) {
                    attackVal = currVal;
                    saveAttack();
                } else if (piece.getColor() == BLACK && currVal >= attackVal) {
                    attackVal = currVal;
                    saveAttack();
                }
                undoSingleAttack();
            }
            if (savedAttack.getMove().size() == 1 && savedAttack.getBestCurrAttack().size() > 0) {
                savedAttack.setAttack(savedAttack.getBestCurrAttack());
                savedAttack.setCapturedPieces(savedAttack.getBestCurrAttackCapturedPieces());
            }
            return attackVal;
        }
        return miniMax(movesAhead - 1, alpha, beta);
    }

    /** Once an optimal attack is found, it is saved so the AI can take it once the minimax algorithm has completed. */
    private void saveAttack() {
        Move move = savedMoves.getLast();
        LinkedList<int[]> currAttacks = move.getMove();
        LinkedList<Piece> currCapturedPieces = move.getCapturedPieces();
        LinkedList<int[]> savedAttacks = new LinkedList<>();
        LinkedList<Piece> savedCapturedPieces = new LinkedList<>();

        if (currAttacks.size() < move.getBestCurrAttack().size()) {
            return;
        }

        for (int i = 0; i < currAttacks.size(); i++) {
            savedAttacks.add(currAttacks.get(i));
            savedCapturedPieces.add(currCapturedPieces.get(i));
        }
        move.setBestCurrAttack(savedAttacks);
        move.setBestCurrAttackCapturedPieces(savedCapturedPieces);
    }

    /** Updates the Checkers board GUI to reflect the attack made by the AI. The attack is made by PIECE, its attacks are contained in
     *  ATTACKSMADE, the captured opponent pieces are contained in CAPTUREDPIECES, and all of the tiles to which PIECE moves during
     *  the attack are contained in PREVIOUSTILES. */
    private void updateGUIPostAttack(BlackPiece piece, LinkedList<int[]> attacksMade, LinkedList<Piece> capturedPieces, LinkedList<BorderPane> previousTiles) {
        int[] attack = attacksMade.pollFirst();
        BorderPane previousTile = previousTiles.pollFirst();
        Text capturedRedCount = boardGUI.getCapturedRedCount();

        BorderPane capturedPieceTile = Controller.findTile(attack[2] - 1, attack[3] - 1);
        BorderPane destTile = Controller.findTile(attack[0] - 1, attack[1] - 1);
        PauseTransition pause = new PauseTransition();

        pause.setDuration(new Duration(500));
        pause.setOnFinished(f -> {
            Controller.addPieceToSidePanel(capturedPieces.pollFirst());
            capturedRedCount.setText((Integer.parseInt(capturedRedCount.getText()) + 1) + "");
            previousTile.getChildren().clear();
            capturedPieceTile.getChildren().clear();
            destTile.setCenter(piece.getGUIpiece());

            if (attacksMade.size() == 0 && (attack[0] - 1) == 7 && piece.getType() == REGULAR) {
                Controller.makeKing(piece, BLACK);
                Controller.displayText("King me!");
            } else if (attacksMade.size() == 0) {
                if (!Controller.gameOver()) {
                    Controller.displayText("Your move.");
                } else {
                    Controller.displayText("I win!");
                }
            } else {
                updateGUIPostAttack(piece, attacksMade, capturedPieces, previousTiles);
            }
        });
        pause.play();
    }

    /** Updates the Checkers board to reflect the move made by the AI. The move is made by PIECE, PREVIOUSTILE is the tile on which PIECE
     *  exists before the move, and DESTTILE is the tile to which PIECE moves. */
    private void updateGUIPostMove(BlackPiece piece, BorderPane previousTile, BorderPane destTile) {
        PauseTransition pause = new PauseTransition();
        pause.setDuration(new Duration(500));
        pause.setOnFinished(f -> {
            previousTile.getChildren().clear();
            destTile.setCenter(piece.getGUIpiece());

            if (piece.getCurrRow() == 7 && piece.getType() == REGULAR) {
                Controller.makeKing(piece, BLACK);
                Controller.displayText("King me!");
            } else {
                Controller.displayText("Your move.");
            }
        });
        pause.play();
    }

    /** Finds all of the possible moves that PIECE can make and returns a LinkedList which contains them. */
    private LinkedList<int[]> searchForMoves(Piece piece) {
        int currRow = piece.getCurrRow();
        int currCol = piece.getCurrCol();
        LinkedList<int[]> possibleMoves = new LinkedList<>();

        if (piece.getType() == KING) {
            if (board.getPieceGUILoc(currRow + 1, currCol + 1) == null) {
                possibleMoves.add(new int[]{currRow + 1, currCol + 1});
            }
            if (board.getPieceGUILoc(currRow + 1, currCol - 1) == null) {
                possibleMoves.add(new int[]{currRow + 1, currCol - 1});
            }
            if (board.getPieceGUILoc(currRow - 1, currCol + 1) == null) {
                possibleMoves.add(new int[]{currRow - 1, currCol + 1});
            }
            if (board.getPieceGUILoc(currRow - 1, currCol - 1) == null) {
                possibleMoves.add(new int[]{currRow - 1, currCol - 1});
            }
        } else {
            if (piece.getColor() == RED) {
                if (board.getPieceGUILoc(currRow - 1, currCol + 1) == null) {
                    possibleMoves.add(new int[]{currRow - 1, currCol + 1});
                }
                if (board.getPieceGUILoc(currRow - 1, currCol - 1) == null) {
                    possibleMoves.add(new int[]{currRow - 1, currCol - 1});
                }
            } else {
                if (board.getPieceGUILoc(currRow + 1, currCol + 1) == null) {
                    possibleMoves.add(new int[]{currRow + 1, currCol + 1});
                }
                if (board.getPieceGUILoc(currRow + 1, currCol - 1) == null) {
                    possibleMoves.add(new int[]{currRow + 1, currCol - 1});
                }
            }
        }
        return possibleMoves;
    }
}
